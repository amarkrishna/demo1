<html>
<head>
	<title>Contributing to Magpie</title>
	<link rel="stylesheet" href="style.css" type="text/css" media="screen"/>
</head>
<body>
<div id="wrapper">
	<h1>Contributing to Magpie</h1>
	<p>Magpie is designed to be easy to modify and adapt to new problems. This part of the manual explains some of the basic tasks required for implementing new features (i.e. how to build Magpie from source), introduces the Java interface to Magpie, and provides a simple example for constructing a new feature.</p>
	
	<h2>Building Magpie</h2>
	<p>There are two methods for compiling a new version of Magpie: using an automated build script provided with Magpie and through an Integrated Development Environment (IDE). For both methods, you will need to install version 7 (or greater) the Java Development Kit (JDK) [LW 9Sept14: Add link!].
	
	<p>The first method for building Magpie is using Apache ANT [LW 9Sept14: Get link], which is kind of a Java-centric version of Make. To use it, simply copy or link <code>simple-build.xml</code> to <code>build.xml</code> in the Magpie root directory. Then, call <code>ant jar</code> and Ant will take care of compiling the source code, linking the libraries, and storing it all in the <code>dist</code> directory.</p>
	
	<p>The alternative (and recommended) method is to use an IDE to build Magpie. If you haven't already used one, IDEs are tools that provide a single platform for editing, debugging, and preparing software for distribution. Many (like <a href="netbeans.org">Netbeans</a>), have handy features like automatic code generation, error checking, and tools for automatically restructuring your code. There are a variety of IDEs available for writing Java programs, and you are probably better off reading their own guides for setting up a new project. Just keep in mind that you may need to tell the IDE to link with all of the libraries in the <code>required-libraries</code> directory.</p>
	
	<h2>Java Interface for Magpie</h2>
	<p>Before creating a new component for Magpie, you might want to get familiar with the Java interface to Magpie first. If you are already accustomed to the command-line interface to Magpie, the structure of the library and the names of operations are might be eerily familiar. If not, you might want to check out the <a href="../examples/index.html">examples</a> scripts to get an idea about what Dataset and Model objects are and how they are used.</p>
	
	<p>Most operations that one performs on a variable in the command-line interface directly map to an operation in Java. For instance, the command <code>submodel set &lt;index&gt $leaf</code> on a model corresponds to the <code>setModel(int index, BaseModel model)</code> function of a class that implements the SplitModel interface.</p>
	
	<p>The key exception to the "for any text command, there is a Java function" rule are text commands that involve a "method" parameter. In these cases, Magpie first searches for a class whose name matches the "method", then creates an instance of that variable (with the options you specified), and then uses that variable to do something. For example, calling "<code>data modify NonZeroClassModifier</code>" creates an instance of the NonZeroClassModifier and calls the modify operation of NonZeroClassModifier to make changes to <code>data</code>. Moral of the story: For commands that involve a "method" parameter, look for an class that performs the task you are looking to do.</p>
	
	<h3>Main Types of Classes</h3>
	<p>As alluded to in the previous section, Magpie is built using many independent classes that each perform a specific tasks. These classes are all unique versions of several main archetypes, which are referred to as "BaseClasses." If you look in the list of classes in the <a href="../javadoc/index.html">Javadoc</a>, you may notice many classes that start with "Base". Each of these are not actually usable in themselves, but provide a starting point for all classes designed to perform a specific operation. For instance, all classes that filter a Dataset are extensions of BaseDatasetFilter. While you can access a complete list of variable types in the Javadoc, here are a few of the ones that are the most useful:
	
	<ul>
	<li><a href="../javadoc/magpie/data/Dataset.html/">Dataset</a>: Stores data of any arbitrary type, as long as you can represent each point as a unique list of numbers</li>
	<li><a href="../javadoc/magpie/data/materials/CompositionDataset.html/">CompositionDataset</a>: Dataset for materials that can be uniquely identified based on their composition. Provides the ability to calculate attributes that can be used for machine learning</li>
	<li><a href="../javadoc/magpie/models/BaseModel.html">BaseModel</a>: Base class for all models. From this Javadoc page, you can access a listing of all model types currently available in Magpie for both classification and regression.</li>
	<li><a href="../javadoc/magpie/models/regression/WekaRegression.html">WekaRegression</a>: Interface to using the Weka machine learning library through Magpie.</li>
	<li><a href="../javadoc/magpie/models/classification/SplitClassifier.html">SplitClassifier</a>: A model that can use other models to handle different kinds of data. Use this if, for instance, you want to have a model that handles intermetallics and ceramics differently.</li>
	<li><a href="../javadoc/magpie/optimization/algorithms/ActiveLearningOptimizer.html">ActiveLearningOptimizer</a>: If provided with a model template and a way of evaluating new entries, can use machine learning to efficiently search space of possible choices to find the interesting ones faster.</li>
	<li><a href="../javadoc/magpie/data/utilities/splitters/BaseDatasetSplitter.html">BaseSplitter</a>: Implementations of this class are designed to split a Dataset into multiple parts based on some criterion.</li>
	</ul>
	
	<h2>Extending Magpie</h2>
	<p>Now that you have a good understanding how to compile your new changes and how to make sense of what code is already in Magpie, its time to discuss how to write new components.</p>
	
	<h3>Adding New Components</h3>
	<p>Adding new functionality to Magpie will more than likely involve implementing a new version of some archetypal "Base" class (see previous section if this makes no sense at all). For these tasks, the best way to create a new implementation is to find an implementation closest to what you want to do, and copy it. Make sure to place the new file in the same directory as the old implementation (very important when compiling Magpie). Once you have done that, follow this simple procedure:</p>
	
	<ol>
	<li><b>Document What You Want to Do</b>: Java has a wonderful documentation generation tool. So, before you get too distracted in writing code, write out the goal of what you want this new filter or model or whatever to in the section of documentation above the "public class" line. Everyone will thank you, or at least feel less confused about why documentation for a totally different tool is at the top of your file.</li>
	<li><b>Find Out What You Will Change</b>: Read the documentation in the base class to find out which operations you need to write. If there isn't some kind of guide on what this base class does, you have been cheated and should complain to whoever is in charge of Magpie (hopefully not you).</li>
	<li><b>Actually Make Changes</b>: Hopefully, the code already in your file does something similar to what you wanted to accomplish. If so, this step should be decently easy.</li>
	<ol>
	
	<h3>Adding New Text Commands</h3>
	<p>Creating new text commands for the Magpie interface is certainly a more advanced topic. The general idea for adding a new command to alter the the runCommand(List&lt;Object&gt;) operation for the object in question. The source code for BaseModel and its implementations should give you a detailed set of examples for how to write new commands and how to document them. Read the JavaDoc for <a href="../javadoc/magpie/utility/interfaces/Commandable.html">Commandable</a> for more details on both.</p>
	
	<p>A few pitfalls to watch out for:</p>
	
	<ul>
	<li>Forgetting to document your command</li>
	<li>Not checking the input to the function first</li>
	<li>Failing to return or "break" from a switch statement after executing operation</li>
	<li>When overloading runCommand, not calling the superclass for commands besides the new one you are implementing</li>
	</ul>
	
</div>
</body>
</html>